-- FleischPanel — correções: remote não bloqueia + minimizar seguro + opcional Kick(K)

local Players             = game:GetService("Players")
local ReplicatedStorage   = game:GetService("ReplicatedStorage")
local TweenService        = game:GetService("TweenService")
local UserInputService    = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

-- =============== (1) Buscar Remote sem travar ===============
local function locateExecuteCommandRemote(timeout)
    timeout = timeout or 2
    -- estrutura comum em pastas: Packages/Net/RE/AdminPanelService/ExecuteCommand
    local packages = ReplicatedStorage:FindFirstChild("Packages")
    local net      = packages and packages:FindFirstChild("Net")
    local re       = net and net:FindFirstChild("RE")
    local svc      = re and re:FindFirstChild("AdminPanelService")
    local remote   = svc and svc:FindFirstChild("ExecuteCommand")

    if remote then return remote end

    -- fallback: objeto com nome único (pouco comum, mas seu código original tentava isso)
    local ok, r2 = pcall(function()
        return net and net:WaitForChild("RE/AdminPanelService/ExecuteCommand", timeout)
    end)
    if ok and r2 then return r2 end

    -- último fallback: tentar esperar cada etapa com timeout curto (sem travar o script)
    local function safeWait(parent, name)
        if not parent then return nil end
        local ok2, obj = pcall(function() return parent:WaitForChild(name, timeout) end)
        return ok2 and obj or nil
    end

    packages = packages or ReplicatedStorage:FindFirstChild("Packages")
    net      = net      or safeWait(packages, "Net")
    re       = re       or (net and net:FindFirstChild("RE")) or safeWait(net, "RE")
    svc      = svc      or (re and re:FindFirstChild("AdminPanelService")) or (re and safeWait(re, "AdminPanelService"))
    remote   = remote   or (svc and svc:FindFirstChild("ExecuteCommand")) or (svc and safeWait(svc, "ExecuteCommand"))

    return remote -- pode ser nil; UI continua viva mesmo assim
end

local remote = locateExecuteCommandRemote(2)

-- =============== (2) Comandos (ativados só se o remote existir) ===============
local comandos = { "ragdoll","balloon","jail","morph","jumpscare","inverse","tiny","rocket" }

local function executarComandos(playerName)
    if not remote then
        warn("[FleischPanel] Remote não encontrado. Botões desativados.")
        return
    end
    if not playerName or playerName == "" then return end

    task.spawn(function()
        for _,cmd in ipairs(comandos) do
            local nomeConsulta = tostring(playerName)
            if nomeConsulta:sub(1,1) == "@" then nomeConsulta = nomeConsulta:sub(2) end
            local alvo = Players:FindFirstChild(nomeConsulta)
            if alvo then
                if cmd == "rocket" then task.wait(3) end
                remote:FireServer(alvo, cmd)
            end
            task.wait(0.25)
        end
    end)
end

-- =============== (3) Limpa UI anterior e cria a nova ===============
if playerGui:FindFirstChild("CmdUI") then
    playerGui.CmdUI:Destroy()
end

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CmdUI"
screenGui.ResetOnSpawn = false
screenGui.DisplayOrder = 999
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.Parent = playerGui

-- Frame principal
local frame = Instance.new("Frame")
frame.Size = UDim2.new(0, 220, 0, 280)
frame.Position = UDim2.new(1, -240, 0.5, -140) -- canto direito
frame.BackgroundColor3 = Color3.fromRGB(14, 17, 22)
frame.BorderSizePixel = 0
frame.Active = true
frame.Parent = screenGui

-- Draggable (suave) pelo header
do
    local dragging, dragStart, startPos
    frame.InputBegan:Connect(function(input)
        -- vamos habilitar drag só quando começar no header (definido mais abaixo)
    end)
    -- definiremos os handlers no header depois de criar o header
end

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 15)
corner.Parent = frame

local frameStroke = Instance.new("UIStroke")
frameStroke.Thickness = 1
frameStroke.Color = Color3.fromRGB(70, 70, 100)
frameStroke.Transparency = 0.3
frameStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
frameStroke.Parent = frame

-- =============== Header (sempre visível) ===============
local header = Instance.new("Frame")
header.Size = UDim2.new(1, 0, 0, 40)
header.Position = UDim2.new(0, 0, 0, 0)
header.BackgroundColor3 = Color3.fromRGB(14, 17, 22)
header.BorderSizePixel = 0
header.Parent = frame

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 15)
headerCorner.Parent = header

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, -80, 1, 0)
title.Position = UDim2.new(0, 10, 0, 0)
title.BackgroundTransparency = 1
title.Text = "FleischPanel"
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Font = Enum.Font.GothamBold
title.TextSize = 18
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header

-- Botão minimizar (colapsa conteúdo; header fica)
local minimizeBtn = Instance.new("TextButton")
minimizeBtn.Size = UDim2.new(0, 26, 0, 26)
minimizeBtn.Position = UDim2.new(1, -36, 0.5, -13)
minimizeBtn.BackgroundColor3 = Color3.fromRGB(24, 28, 36)
minimizeBtn.TextColor3 = Color3.new(1,1,1)
minimizeBtn.Font = Enum.Font.GothamBold
minimizeBtn.TextSize = 16
minimizeBtn.Text = "—"
minimizeBtn.AutoButtonColor = true
minimizeBtn.Parent = header
local minimizeCorner = Instance.new("UICorner"); minimizeCorner.CornerRadius = UDim.new(0,8); minimizeCorner.Parent = minimizeBtn
local minimizeStroke = Instance.new("UIStroke"); minimizeStroke.Thickness = 1; minimizeStroke.Color = Color3.fromRGB(70,70,100); minimizeStroke.Transparency = 0.3; minimizeStroke.Parent = minimizeBtn

-- =============== Conteúdo (pode ser colapsado) ===============
local content = Instance.new("Frame")
content.Size = UDim2.new(1, 0, 1, -40)
content.Position = UDim2.new(0, 0, 0, 40)
content.BackgroundTransparency = 1
content.Parent = frame

-- ScrollingFrame
local scrolling = Instance.new("ScrollingFrame")
scrolling.Size = UDim2.new(1, -20, 1, -20)
scrolling.Position = UDim2.new(0, 10, 0, 10)
scrolling.BackgroundColor3 = Color3.fromRGB(14, 17, 22)
scrolling.BorderSizePixel = 0
scrolling.ScrollBarThickness = 8
scrolling.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 120)
scrolling.CanvasSize = UDim2.new(0, 0, 0, 0)
scrolling.AutomaticCanvasSize = Enum.AutomaticSize.Y
scrolling.Parent = content

local scrollCorner = Instance.new("UICorner")
scrollCorner.CornerRadius = UDim.new(0, 10)
scrollCorner.Parent = scrolling

local listLayout = Instance.new("UIListLayout")
listLayout.Parent = scrolling
listLayout.Padding = UDim.new(0, 8)
listLayout.SortOrder = Enum.SortOrder.LayoutOrder

local padding = Instance.new("UIPadding")
padding.PaddingTop = UDim.new(0, 8)
padding.PaddingBottom = UDim.new(0, 8)
padding.PaddingLeft = UDim.new(0, 8)
padding.PaddingRight = UDim.new(0, 8)
padding.Parent = scrolling

-- Mensagem de estado (ex.: remote ausente)
local statusLabel = Instance.new("TextLabel")
statusLabel.BackgroundTransparency = 1
statusLabel.Size = UDim2.new(1, -20, 0, 20)
statusLabel.Position = UDim2.new(0, 10, 0, 10)
statusLabel.Text = remote and "" or "Aviso: Remote não encontrado. Botões desativados."
statusLabel.TextColor3 = Color3.fromRGB(255, 200, 120)
statusLabel.Font = Enum.Font.Gotham
statusLabel.TextSize = 12
statusLabel.TextXAlignment = Enum.TextXAlignment.Left
statusLabel.Parent = content

-- Botões de jogador
local function criarBotao(playerObj)
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(1, -16, 0, 40)
    btn.BackgroundColor3 = Color3.fromRGB(14, 17, 22)
    btn.Text = ""
    btn.BorderSizePixel = 0
    btn.AutoButtonColor = true
    btn.Parent = scrolling

    local cornerBtn = Instance.new("UICorner")
    cornerBtn.CornerRadius = UDim.new(0, 10)
    cornerBtn.Parent = btn

    local btnStroke = Instance.new("UIStroke")
    btnStroke.Thickness = 1
    btnStroke.Color = Color3.fromRGB(70, 70, 100)
    btnStroke.Transparency = 0.4
    btnStroke.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
    btnStroke.Parent = btn

    local playerName = Instance.new("TextLabel")
    playerName.Size = UDim2.new(1, -50, 1, 0)
    playerName.Position = UDim2.new(0, 10, 0, 0)
    playerName.BackgroundTransparency = 1
    playerName.Text = playerObj.Name
    playerName.TextColor3 = Color3.fromRGB(255, 255, 255)
    playerName.Font = Enum.Font.GothamBold
    playerName.TextSize = 14
    playerName.TextXAlignment = Enum.TextXAlignment.Left
    playerName.Parent = btn

    local hoverTween = TweenService:Create(btn, TweenInfo.new(0.15, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(24, 28, 36) })
    local unhoverTween = TweenService:Create(btn, TweenInfo.new(0.2, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), { BackgroundColor3 = Color3.fromRGB(14, 17, 22) })
    btn.MouseEnter:Connect(function() hoverTween:Play() end)
    btn.MouseLeave:Connect(function() unhoverTween:Play() end)

    btn.MouseButton1Click:Connect(function()
        if remote then
            executarComandos(playerObj.Name)
        else
            warn("[FleischPanel] Remote ausente. Clique ignorado.")
        end
    end)
end

local function atualizarLista()
    -- remove antigos
    for _, child in ipairs(scrolling:GetChildren()) do
        if child:IsA("TextButton") then child:Destroy() end
    end
    -- recria
    for _, p in ipairs(Players:GetPlayers()) do
        if p ~= player then criarBotao(p) end
    end
    -- status
    statusLabel.Text = remote and "" or "Aviso: Remote não encontrado. Botões desativados."
end

-- loop atualização
task.spawn(function()
    while screenGui.Parent do
        atualizarLista()
        task.wait(2)
    end
end)
atualizarLista()

-- =============== Minimizar sem sumir ===============
local collapsed = false
local function toggleMinimize()
    collapsed = not collapsed
    content.Visible = not collapsed           -- só esconde o conteúdo
    minimizeBtn.Text = collapsed and "□" or "—"
end

-- CTRL para alternar
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.KeyCode == Enum.KeyCode.LeftControl or input.KeyCode == Enum.KeyCode.RightControl then
        toggleMinimize()
    end
end)

-- Arrastar pelo header (agora que ele existe)
do
    local dragging, dragStart, startPos
    header.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging, dragStart, startPos = true, input.Position, frame.Position
        end
    end)
    header.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)
    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
        end
    end)
end

-- Botão minimizar também alterna
minimizeBtn.MouseButton1Click:Connect(toggleMinimize)

-- =============== Opcional: Auto-Kick (K) ===============
-- Remova esta seção se não quiser o atalho de sair rápido.
local function doSelfKick()
    local msg = "Você foi removido pelo sistema de moderação.\n(Code: 268)"
    pcall(function() player:Kick(msg) end)
end
UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == Enum.KeyCode.K then
        doSelfKick()
    end
end)
